<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Labyrinth</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #0a0a0a;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #breadcrumb-trail {
            position: absolute;
            top: 16px;
            left: 16px;
            font-size: 14px;
            opacity: 1;
            transition: opacity 2s;
            pointer-events: auto;
        }

        #breadcrumb-trail span {
            cursor: pointer;
            transition: opacity 0.5s;
        }

        #breadcrumb-trail span:hover {
            text-decoration: underline;
        }

        #level-indicator {
            position: absolute;
            top: 16px;
            right: 16px;
            font-size: 12px;
            opacity: 0.5;
        }

        #hint {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 13px;
            opacity: 0.4;
            text-align: center;
            pointer-events: auto;
            max-width: 600px;
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            opacity: 0;
            transition: opacity 1.5s;
            text-align: center;
            line-height: 1.6;
            pointer-events: none;
        }

        #message.visible {
            opacity: 1;
        }

        .fade-breadcrumb {
            opacity: 0.15 !important;
        }

        #entry-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            background: #0a0a0a;
            transition: opacity 1.5s;
            pointer-events: auto;
        }

        #entry-screen h1 {
            font-size: 48px;
            letter-spacing: 16px;
            margin-bottom: 40px;
            font-weight: 300;
        }

        #entry-screen p {
            font-size: 14px;
            opacity: 0.5;
            margin-bottom: 60px;
            max-width: 500px;
            text-align: center;
            line-height: 1.8;
        }

        #enter-btn {
            background: none;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 14px 48px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            cursor: pointer;
            letter-spacing: 4px;
            transition: all 0.3s;
            pointer-events: auto;
        }

        #enter-btn:hover {
            border-color: #aaa;
            background: #1a1a1a;
        }
    </style>
</head>
<body>

<canvas id="labyrinth"></canvas>

<div id="ui-overlay">
    <div id="breadcrumb-trail"></div>
    <div id="level-indicator"></div>
    <div id="hint"></div>
    <div id="message"></div>
</div>

<div id="entry-screen">
    <h1>THE LABYRINTH</h1>
    <p>
        Each step takes you deeper.<br>
        The deeper you go, the harder it is to return.<br>
        But there is always a way back — if you follow the logic.<br><br>
        Pay attention. Remember the pattern.
    </p>
    <button id="enter-btn">ENTER</button>
</div>

<script>
// ============================================================
// THE LABYRINTH - A dimensional journey
// ============================================================

const canvas = document.getElementById('labyrinth');
const ctx = canvas.getContext('2d');
const W = () => canvas.width;
const H = () => canvas.height;

let currentLevel = 0;
let animFrame = null;
let time = 0;
let mouseX = 0, mouseY = 0;
let breadcrumbs = [];
let fadeTimer = null;

// Resize canvas
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Track mouse
window.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
});

// ============================================================
// ENTRY
// ============================================================
document.getElementById('enter-btn').addEventListener('click', () => {
    const screen = document.getElementById('entry-screen');
    screen.style.opacity = '0';
    setTimeout(() => {
        screen.style.display = 'none';
        startLevel(0);
    }, 1500);
});

// ============================================================
// LEVEL MANAGEMENT
// ============================================================
function startLevel(level) {
    currentLevel = level;
    if (animFrame) cancelAnimationFrame(animFrame);
    time = 0;

    updateBreadcrumbs(level);
    updateUI(level);

    const renderers = [renderLevel0, renderLevel1, renderLevel2, renderLevel3, renderLevel4];
    const loop = () => {
        time += 0.016;
        renderers[level]();
        animFrame = requestAnimationFrame(loop);
    };
    loop();
}

function updateBreadcrumbs(level) {
    const names = ['Origin', 'The Grid', 'The Corridors', 'The Tesseract', 'The Core'];

    if (level > breadcrumbs.length) {
        // Going deeper
        for (let i = breadcrumbs.length; i < level; i++) {
            breadcrumbs.push(i);
        }
    }

    const trail = document.getElementById('breadcrumb-trail');
    trail.innerHTML = '';

    // The trick: breadcrumbs fade based on depth difference
    // At deeper levels, earlier breadcrumbs become harder to see
    for (let i = 0; i <= Math.min(level, names.length - 1); i++) {
        const span = document.createElement('span');
        const depthDiff = level - i;
        // Exponential fade: deeper = harder to see earlier crumbs
        const opacity = Math.max(0.08, 1 - (depthDiff * 0.25));
        span.style.opacity = opacity;
        span.style.color = i === level ? '#fff' : '#888';
        span.textContent = names[i];
        span.addEventListener('click', () => navigateBack(i));

        if (i > 0) {
            const sep = document.createElement('span');
            sep.textContent = ' → ';
            sep.style.opacity = opacity;
            trail.appendChild(sep);
        }
        trail.appendChild(span);
    }
}

function updateUI(level) {
    const hints = [
        'Click the pulsing cell to descend.',
        'Find the gap in the walls. The maze shifts, but the exit glows.',
        'Perspective deceives. Move toward what feels wrong.',
        'The hypercube folds. Find the face that doesn\'t belong.',
        'You found the core. Every path led here. Click anywhere to return.'
    ];
    const depths = ['Surface', 'Depth 1 — Flatland', 'Depth 2 — Perspective', 'Depth 3 — Hyperspace', 'Depth 4 — The Core'];

    document.getElementById('hint').textContent = hints[level];
    document.getElementById('level-indicator').textContent = depths[level];
}

function navigateBack(targetLevel) {
    showMessage(targetLevel < currentLevel ? 'Ascending...' : '');
    setTimeout(() => {
        hideMessage();
        startLevel(targetLevel);
    }, 1000);
}

function showMessage(text) {
    const msg = document.getElementById('message');
    msg.textContent = text;
    msg.classList.add('visible');
}

function hideMessage() {
    document.getElementById('message').classList.remove('visible');
}

function goDeeper() {
    if (currentLevel >= 4) return;
    const messages = [
        'The ground shifts beneath you...',
        'Walls rise. Dimensions multiply...',
        'Space folds. Time bends...',
        'You have reached the core.'
    ];
    showMessage(messages[currentLevel]);
    setTimeout(() => {
        hideMessage();
        startLevel(currentLevel + 1);
    }, 1800);
}

// ============================================================
// LEVEL 0 — THE FLAT GRID (2D)
// Simple grid of cells. One pulses. Click it to go deeper.
// ============================================================
let level0Target = null;

function renderLevel0() {
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, W(), H());

    const cols = 12;
    const rows = 8;
    const cellW = W() / cols;
    const cellH = H() / rows;

    if (!level0Target) {
        level0Target = {
            col: Math.floor(Math.random() * cols),
            row: Math.floor(Math.random() * rows)
        };
        canvas.onclick = handleLevel0Click;
    }

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const x = c * cellW;
            const y = r * cellH;

            const isTarget = c === level0Target.col && r === level0Target.row;
            const pulse = Math.sin(time * 3) * 0.5 + 0.5;

            ctx.strokeStyle = isTarget
                ? `rgba(120, 200, 255, ${0.3 + pulse * 0.7})`
                : 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = isTarget ? 2 : 0.5;
            ctx.strokeRect(x + 2, y + 2, cellW - 4, cellH - 4);

            if (isTarget) {
                ctx.fillStyle = `rgba(120, 200, 255, ${pulse * 0.1})`;
                ctx.fillRect(x + 2, y + 2, cellW - 4, cellH - 4);
            }
        }
    }
}

function handleLevel0Click(e) {
    if (currentLevel !== 0) return;
    const cols = 12, rows = 8;
    const cellW = W() / cols;
    const cellH = H() / rows;
    const col = Math.floor(e.clientX / cellW);
    const row = Math.floor(e.clientY / cellH);
    if (col === level0Target.col && row === level0Target.row) {
        level0Target = null;
        canvas.onclick = null;
        goDeeper();
    }
}

// ============================================================
// LEVEL 1 — THE MAZE (2D with walls)
// A generated maze. Find the glowing exit.
// ============================================================
let maze = null;
let mazePlayer = null;

function generateMaze(w, h) {
    const grid = Array.from({ length: h }, () =>
        Array.from({ length: w }, () => ({ top: true, right: true, bottom: true, left: true, visited: false }))
    );

    const stack = [];
    let cur = { x: 0, y: 0 };
    grid[0][0].visited = true;

    function neighbors(x, y) {
        const n = [];
        if (y > 0 && !grid[y-1][x].visited) n.push({ x, y: y-1, dir: 'top' });
        if (x < w-1 && !grid[y][x+1].visited) n.push({ x: x+1, y, dir: 'right' });
        if (y < h-1 && !grid[y+1][x].visited) n.push({ x, y: y+1, dir: 'bottom' });
        if (x > 0 && !grid[y][x-1].visited) n.push({ x: x-1, y, dir: 'left' });
        return n;
    }

    const opposite = { top: 'bottom', bottom: 'top', left: 'right', right: 'left' };
    let totalVisited = 1;
    const total = w * h;

    while (totalVisited < total) {
        const nb = neighbors(cur.x, cur.y);
        if (nb.length > 0) {
            const next = nb[Math.floor(Math.random() * nb.length)];
            stack.push(cur);
            grid[cur.y][cur.x][next.dir] = false;
            grid[next.y][next.x][opposite[next.dir]] = false;
            cur = { x: next.x, y: next.y };
            grid[cur.y][cur.x].visited = true;
            totalVisited++;
        } else {
            cur = stack.pop();
        }
    }

    return grid;
}

function renderLevel1() {
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, W(), H());

    const mw = 16, mh = 10;
    if (!maze) {
        maze = generateMaze(mw, mh);
        mazePlayer = { x: 0, y: 0 };
        canvas.onclick = null;
        window.addEventListener('keydown', handleMazeKey);
    }

    const cellW = W() / mw;
    const cellH = H() / mh;
    const exitX = mw - 1, exitY = mh - 1;

    for (let r = 0; r < mh; r++) {
        for (let c = 0; c < mw; c++) {
            const cell = maze[r][c];
            const x = c * cellW;
            const y = r * cellH;

            ctx.strokeStyle = 'rgba(100, 180, 255, 0.3)';
            ctx.lineWidth = 2;

            if (cell.top) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + cellW, y); ctx.stroke(); }
            if (cell.bottom) { ctx.beginPath(); ctx.moveTo(x, y + cellH); ctx.lineTo(x + cellW, y + cellH); ctx.stroke(); }
            if (cell.left) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + cellH); ctx.stroke(); }
            if (cell.right) { ctx.beginPath(); ctx.moveTo(x + cellW, y); ctx.lineTo(x + cellW, y + cellH); ctx.stroke(); }
        }
    }

    // Exit glow
    const pulse = Math.sin(time * 2) * 0.5 + 0.5;
    ctx.fillStyle = `rgba(255, 200, 80, ${0.1 + pulse * 0.2})`;
    ctx.fillRect(exitX * cellW, exitY * cellH, cellW, cellH);
    ctx.strokeStyle = `rgba(255, 200, 80, ${0.5 + pulse * 0.5})`;
    ctx.lineWidth = 2;
    ctx.strokeRect(exitX * cellW + 4, exitY * cellH + 4, cellW - 8, cellH - 8);

    // Player
    const px = mazePlayer.x * cellW + cellW / 2;
    const py = mazePlayer.y * cellH + cellH / 2;
    const pr = Math.min(cellW, cellH) * 0.25;

    ctx.beginPath();
    ctx.arc(px, py, pr, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(120, 220, 255, 0.9)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(120, 220, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(px, py, pr + 6 + Math.sin(time * 4) * 3, 0, Math.PI * 2);
    ctx.stroke();
}

function handleMazeKey(e) {
    if (currentLevel !== 1 || !maze) return;
    const mw = 16, mh = 10;
    const { x, y } = mazePlayer;
    const cell = maze[y][x];

    if ((e.key === 'ArrowUp' || e.key === 'w') && !cell.top) mazePlayer.y--;
    if ((e.key === 'ArrowDown' || e.key === 's') && !cell.bottom) mazePlayer.y++;
    if ((e.key === 'ArrowLeft' || e.key === 'a') && !cell.left) mazePlayer.x--;
    if ((e.key === 'ArrowRight' || e.key === 'd') && !cell.right) mazePlayer.x++;

    if (mazePlayer.x === mw - 1 && mazePlayer.y === mh - 1) {
        window.removeEventListener('keydown', handleMazeKey);
        maze = null;
        mazePlayer = null;
        goDeeper();
    }
}

// ============================================================
// LEVEL 2 — THE CORRIDORS (Pseudo-3D)
// Raycasting-style perspective corridors. Disorienting.
// ============================================================
let corridorAngle = 0;
let corridorPos = { x: 1.5, y: 1.5 };
let corridorMap = null;
let corridorExitFound = false;

function renderLevel2() {
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, W(), H());

    if (!corridorMap) {
        corridorMap = [
            [1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,1,0,0,0,0,1],
            [1,0,1,0,1,0,1,1,0,1],
            [1,0,1,0,0,0,0,1,0,1],
            [1,0,1,1,1,1,0,1,0,1],
            [1,0,0,0,0,1,0,0,0,1],
            [1,1,1,0,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,2,1],
            [1,1,1,1,1,1,1,1,1,1]
        ];
        corridorAngle = 0;
        corridorPos = { x: 1.5, y: 1.5 };
        corridorExitFound = false;
        window.addEventListener('keydown', handleCorridorKey);
    }

    const w = W(), h = H();
    const fov = Math.PI / 3;
    const numRays = Math.floor(w / 2);

    for (let i = 0; i < numRays; i++) {
        const rayAngle = corridorAngle - fov / 2 + (i / numRays) * fov;
        const sin = Math.sin(rayAngle);
        const cos = Math.cos(rayAngle);

        let dist = 0;
        let hitType = 0;
        while (dist < 20) {
            dist += 0.02;
            const testX = corridorPos.x + cos * dist;
            const testY = corridorPos.y + sin * dist;
            const mapX = Math.floor(testX);
            const mapY = Math.floor(testY);

            if (mapY >= 0 && mapY < corridorMap.length && mapX >= 0 && mapX < corridorMap[0].length) {
                if (corridorMap[mapY][mapX] >= 1) {
                    hitType = corridorMap[mapY][mapX];
                    break;
                }
            }
        }

        // Fix fisheye
        const perpDist = dist * Math.cos(rayAngle - corridorAngle);
        const wallHeight = Math.min(h, h / perpDist);
        const wallTop = (h - wallHeight) / 2;

        const shade = Math.max(0, 1 - perpDist / 8);
        const wobble = Math.sin(time * 2 + i * 0.05) * (currentLevel >= 2 ? 3 : 0);

        if (hitType === 2) {
            // Exit wall - golden glow
            const pulse = Math.sin(time * 3) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(${Math.floor(255 * shade * pulse)}, ${Math.floor(200 * shade * pulse)}, ${Math.floor(80 * shade * pulse)}, 1)`;
        } else {
            const r = Math.floor(60 * shade);
            const g = Math.floor(100 * shade);
            const b = Math.floor(180 * shade);
            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        }

        const stripW = Math.ceil(w / numRays) + 1;
        ctx.fillRect(i * stripW, wallTop + wobble, stripW, wallHeight);

        // Floor
        const floorShade = 0.15;
        ctx.fillStyle = `rgba(40, 30, 60, ${floorShade})`;
        ctx.fillRect(i * stripW, wallTop + wallHeight + wobble, stripW, h);

        // Ceiling
        ctx.fillStyle = `rgba(20, 15, 40, ${floorShade})`;
        ctx.fillRect(i * stripW, 0, stripW, wallTop + wobble);
    }

    // Minimap (fades with time)
    const miniOpacity = Math.max(0.05, 0.6 - time * 0.02);
    const miniScale = 6;
    const miniX = w - corridorMap[0].length * miniScale - 16;
    const miniY = 40;

    ctx.globalAlpha = miniOpacity;
    for (let r = 0; r < corridorMap.length; r++) {
        for (let c = 0; c < corridorMap[0].length; c++) {
            ctx.fillStyle = corridorMap[r][c] === 1 ? '#446' : corridorMap[r][c] === 2 ? '#a84' : '#111';
            ctx.fillRect(miniX + c * miniScale, miniY + r * miniScale, miniScale - 1, miniScale - 1);
        }
    }
    ctx.fillStyle = '#5bf';
    ctx.fillRect(miniX + corridorPos.x * miniScale - 2, miniY + corridorPos.y * miniScale - 2, 4, 4);
    ctx.globalAlpha = 1;
}

function handleCorridorKey(e) {
    if (currentLevel !== 2 || !corridorMap) return;
    const speed = 0.1;
    const rotSpeed = 0.08;
    let nx = corridorPos.x, ny = corridorPos.y;

    if (e.key === 'ArrowLeft' || e.key === 'a') corridorAngle -= rotSpeed;
    if (e.key === 'ArrowRight' || e.key === 'd') corridorAngle += rotSpeed;
    if (e.key === 'ArrowUp' || e.key === 'w') {
        nx += Math.cos(corridorAngle) * speed;
        ny += Math.sin(corridorAngle) * speed;
    }
    if (e.key === 'ArrowDown' || e.key === 's') {
        nx -= Math.cos(corridorAngle) * speed;
        ny -= Math.sin(corridorAngle) * speed;
    }

    const mapX = Math.floor(nx);
    const mapY = Math.floor(ny);

    if (mapY >= 0 && mapY < corridorMap.length && mapX >= 0 && mapX < corridorMap[0].length) {
        if (corridorMap[mapY][mapX] === 0) {
            corridorPos.x = nx;
            corridorPos.y = ny;
        } else if (corridorMap[mapY][mapX] === 2) {
            window.removeEventListener('keydown', handleCorridorKey);
            corridorMap = null;
            goDeeper();
        }
    }
}

// ============================================================
// LEVEL 3 — THE TESSERACT (4D Hypercube projection)
// Rotating 4D hypercube. Find the face that doesn't belong.
// ============================================================
let tesseractClickHandler = null;
let wrongFace = null;

function renderLevel3() {
    ctx.fillStyle = 'rgba(5, 3, 15, 0.3)';
    ctx.fillRect(0, 0, W(), H());

    const cx = W() / 2;
    const cy = H() / 2;
    const scale = Math.min(W(), H()) * 0.2;

    // 4D hypercube vertices
    const verts4D = [];
    for (let i = 0; i < 16; i++) {
        verts4D.push([
            (i & 1) ? 1 : -1,
            (i & 2) ? 1 : -1,
            (i & 4) ? 1 : -1,
            (i & 8) ? 1 : -1
        ]);
    }

    // 4D rotation matrices (rotate in XW and YZ planes)
    const a = time * 0.4;
    const b = time * 0.3;
    const c = time * 0.2;

    function rotate4D(v) {
        let [x, y, z, w] = v;
        // XW rotation
        let nx = x * Math.cos(a) - w * Math.sin(a);
        let nw = x * Math.sin(a) + w * Math.cos(a);
        x = nx; w = nw;
        // YZ rotation
        let ny = y * Math.cos(b) - z * Math.sin(b);
        let nz = y * Math.sin(b) + z * Math.cos(b);
        y = ny; z = nz;
        // XZ rotation
        nx = x * Math.cos(c) - z * Math.sin(c);
        nz = x * Math.sin(c) + z * Math.cos(c);
        x = nx; z = nz;
        return [x, y, z, w];
    }

    // Project 4D → 3D → 2D
    function project(v4) {
        const [x, y, z, w] = rotate4D(v4);
        const d4 = 2.5;
        const s4 = d4 / (d4 - w);
        const x3 = x * s4;
        const y3 = y * s4;
        const z3 = z * s4;

        const d3 = 4;
        const s3 = d3 / (d3 - z3);
        return {
            x: cx + x3 * s3 * scale,
            y: cy + y3 * s3 * scale,
            depth: z3 + w
        };
    }

    const projected = verts4D.map(project);

    // Edges: connect vertices that differ by exactly one bit
    const edges = [];
    for (let i = 0; i < 16; i++) {
        for (let j = i + 1; j < 16; j++) {
            const diff = i ^ j;
            if (diff && (diff & (diff - 1)) === 0) {
                edges.push([i, j]);
            }
        }
    }

    // Draw edges
    for (const [i, j] of edges) {
        const p1 = projected[i];
        const p2 = projected[j];
        const avgDepth = (p1.depth + p2.depth) / 2;
        const brightness = Math.max(0.1, Math.min(1, 0.5 + avgDepth * 0.2));

        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.strokeStyle = `rgba(150, 100, 255, ${brightness * 0.6})`;
        ctx.lineWidth = brightness * 2;
        ctx.stroke();
    }

    // Draw vertices
    for (let i = 0; i < projected.length; i++) {
        const p = projected[i];
        const size = 3 + (p.depth + 2) * 1.5;

        ctx.beginPath();
        ctx.arc(p.x, p.y, Math.max(1, size), 0, Math.PI * 2);
        ctx.fillStyle = `rgba(200, 150, 255, ${Math.max(0.2, 0.5 + p.depth * 0.15)})`;
        ctx.fill();
    }

    // The "wrong" face - one vertex pulses differently
    if (wrongFace === null) {
        wrongFace = Math.floor(Math.random() * 16);
        canvas.onclick = null;
        tesseractClickHandler = (e) => handleTesseractClick(e, projected);
        canvas.addEventListener('click', tesseractClickHandler);
    }

    // Draw the odd one out with a golden glow
    const wp = projected[wrongFace];
    const wpulse = Math.sin(time * 5) * 0.5 + 0.5;
    ctx.beginPath();
    ctx.arc(wp.x, wp.y, 8 + wpulse * 6, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255, 220, 100, ${0.2 + wpulse * 0.4})`;
    ctx.fill();

    // Particles orbiting
    for (let i = 0; i < 30; i++) {
        const angle = time * (0.5 + i * 0.1) + i * 2.1;
        const radius = 100 + Math.sin(time + i) * 60;
        const px = cx + Math.cos(angle) * radius;
        const py = cy + Math.sin(angle) * radius;
        const psize = 1 + Math.sin(time * 2 + i) * 0.5;

        ctx.beginPath();
        ctx.arc(px, py, psize, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(150, 120, 255, ${0.1 + Math.sin(time + i) * 0.1})`;
        ctx.fill();
    }
}

function handleTesseractClick(e, projected) {
    if (currentLevel !== 3 || wrongFace === null) return;

    const clickX = e.clientX;
    const clickY = e.clientY;

    // Reproject to get current positions
    const cx = W() / 2;
    const cy = H() / 2;
    const scale = Math.min(W(), H()) * 0.2;

    const verts4D = [];
    for (let i = 0; i < 16; i++) {
        verts4D.push([
            (i & 1) ? 1 : -1,
            (i & 2) ? 1 : -1,
            (i & 4) ? 1 : -1,
            (i & 8) ? 1 : -1
        ]);
    }

    const a = time * 0.4, b = time * 0.3, c = time * 0.2;
    function rot(v) {
        let [x, y, z, w] = v;
        let nx = x*Math.cos(a) - w*Math.sin(a); let nw = x*Math.sin(a) + w*Math.cos(a); x=nx; w=nw;
        let ny = y*Math.cos(b) - z*Math.sin(b); let nz = y*Math.sin(b) + z*Math.cos(b); y=ny; z=nz;
        nx = x*Math.cos(c) - z*Math.sin(c); nz = x*Math.sin(c) + z*Math.cos(c); x=nx; z=nz;
        return [x,y,z,w];
    }

    const [x,y,z,w] = rot(verts4D[wrongFace]);
    const d4=2.5; const s4=d4/(d4-w);
    const x3=x*s4, y3=y*s4, z3=z*s4;
    const d3=4; const s3=d3/(d3-z3);
    const px = cx + x3*s3*scale;
    const py = cy + y3*s3*scale;

    const dist = Math.sqrt((clickX - px)**2 + (clickY - py)**2);
    if (dist < 30) {
        canvas.removeEventListener('click', tesseractClickHandler);
        wrongFace = null;
        goDeeper();
    }
}

// ============================================================
// LEVEL 4 — THE CORE (The reward)
// Beautiful, meaningful generative art. The centre of it all.
// ============================================================
function renderLevel4() {
    // Slow fade creates trails
    ctx.fillStyle = 'rgba(5, 2, 15, 0.05)';
    ctx.fillRect(0, 0, W(), H());

    const cx = W() / 2;
    const cy = H() / 2;

    // Sacred geometry - flower of life pattern
    const rings = 7;
    const baseRadius = Math.min(W(), H()) * 0.08;

    for (let ring = 0; ring < rings; ring++) {
        const count = ring === 0 ? 1 : ring * 6;
        const ringRadius = ring * baseRadius * 0.88;

        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2 + time * 0.1 * (ring % 2 === 0 ? 1 : -1);
            const x = cx + Math.cos(angle) * ringRadius;
            const y = cy + Math.sin(angle) * ringRadius;

            // Each circle in the flower
            const circleRadius = baseRadius * (0.9 + Math.sin(time * 0.5 + ring) * 0.1);
            const hue = (ring * 40 + time * 20 + i * 10) % 360;
            const lightness = 50 + Math.sin(time + ring + i) * 20;

            ctx.beginPath();
            ctx.arc(x, y, circleRadius, 0, Math.PI * 2);
            ctx.strokeStyle = `hsla(${hue}, 60%, ${lightness}%, ${0.15 + Math.sin(time * 0.3 + ring) * 0.1})`;
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    // Central mandala
    for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2 + time * 0.15;
        const len = baseRadius * 3 + Math.sin(time * 0.7 + i) * 30;

        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + Math.cos(angle) * len, cy + Math.sin(angle) * len);
        const hue = (i * 30 + time * 15) % 360;
        ctx.strokeStyle = `hsla(${hue}, 70%, 60%, 0.1)`;
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    // Breathing center
    const breathe = Math.sin(time * 0.5) * 0.5 + 0.5;
    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, baseRadius * 2);
    gradient.addColorStop(0, `rgba(255, 255, 255, ${0.05 + breathe * 0.05})`);
    gradient.addColorStop(0.5, `rgba(150, 120, 255, ${0.03 + breathe * 0.02})`);
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

    ctx.beginPath();
    ctx.arc(cx, cy, baseRadius * 2, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.fill();

    // Floating text
    const textOpacity = Math.sin(time * 0.2) * 0.3 + 0.4;
    ctx.font = '14px "Courier New"';
    ctx.fillStyle = `rgba(200, 180, 255, ${textOpacity})`;
    ctx.textAlign = 'center';

    const phrases = [
        'Every complex system has a simple origin.',
        'The way out is the way through.',
        'Dimensions are just perspectives.',
        'You were never lost — only exploring.'
    ];
    const phraseIndex = Math.floor(time * 0.1) % phrases.length;
    ctx.fillText(phrases[phraseIndex], cx, cy + baseRadius * 4);

    // Click to return to origin
    if (!canvas.onclick) {
        canvas.onclick = () => {
            canvas.onclick = null;
            navigateBack(0);
        };
    }
}

</script>
</body>
</html>
